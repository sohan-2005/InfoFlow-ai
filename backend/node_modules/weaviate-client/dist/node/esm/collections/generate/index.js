import { WeaviateInvalidInputError } from '../../errors.js';
import { toBase64FromMedia } from '../../index.js';
import { Deserialize } from '../deserialize/index.js';
import { Check } from '../query/check.js';
import { Serialize } from '../serialize/index.js';
class GenerateManager {
    check;
    constructor(check) {
        this.check = check;
    }
    static use(connection, name, dbVersionSupport, consistencyLevel, tenant) {
        return new GenerateManager(new Check(connection, name, dbVersionSupport, consistencyLevel, tenant));
    }
    async parseReply(reply) {
        const deserialize = await Deserialize.use(this.check.dbVersionSupport);
        return deserialize.generate(reply);
    }
    async parseGroupByReply(opts, reply) {
        const deserialize = await Deserialize.use(this.check.dbVersionSupport);
        return Serialize.search.isGroupBy(opts)
            ? deserialize.generateGroupBy(reply)
            : deserialize.generate(reply);
    }
    fetchObjects(generate, opts) {
        return Promise.all([
            this.check.fetchObjects(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...Serialize.search.fetchObjects(opts),
                generative: await Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withFetch(args))
            .then((reply) => this.parseReply(reply));
    }
    bm25(query, generate, opts) {
        return Promise.all([
            this.check.bm25(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...Serialize.search.bm25(query, opts),
                generative: await Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withBm25(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    hybrid(query, generate, opts) {
        return Promise.all([
            this.check.hybridSearch(opts),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search, supportsVectors }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...(await Serialize.search.hybrid({
                    query,
                    supportsVectors,
                }, opts)),
                generative: await Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withHybrid(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    nearImage(image, generate, opts) {
        return Promise.all([
            this.check.nearSearch(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...Serialize.search.nearImage({
                    image: await toBase64FromMedia(image),
                }, opts),
                generative: await Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withNearImage(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    nearObject(id, generate, opts) {
        return Promise.all([
            this.check.nearSearch(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...Serialize.search.nearObject({
                    id,
                }, opts),
                generative: await Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withNearObject(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    nearText(query, generate, opts) {
        return Promise.all([
            this.check.nearSearch(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...Serialize.search.nearText({
                    query,
                }, opts),
                generative: await Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withNearText(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    nearVector(vector, generate, opts) {
        return Promise.all([
            this.check.nearVector(vector, opts),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search, supportsVectors }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...(await Serialize.search.nearVector({
                    vector,
                    supportsVectors,
                }, opts)),
                generative: await Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withNearVector(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    nearMedia(media, type, generate, opts) {
        return Promise.all([
            this.check.nearSearch(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(([{ search }, supportsSingleGrouped]) => {
            let send;
            switch (type) {
                case 'audio':
                    send = (media, generative) => search.withNearAudio({
                        ...Serialize.search.nearAudio({ audio: media }, opts),
                        generative,
                    });
                    break;
                case 'depth':
                    send = (media, generative) => search.withNearDepth({
                        ...Serialize.search.nearDepth({ depth: media }, opts),
                        generative,
                    });
                    break;
                case 'image':
                    send = (media, generative) => search.withNearImage({
                        ...Serialize.search.nearImage({ image: media }, opts),
                        generative,
                    });
                    break;
                case 'imu':
                    send = (media, generative) => search.withNearIMU({
                        ...Serialize.search.nearIMU({ imu: media }, opts),
                        generative,
                    });
                    break;
                case 'thermal':
                    send = (media, generative) => search.withNearThermal({
                        ...Serialize.search.nearThermal({ thermal: media }, opts),
                        generative,
                    });
                    break;
                case 'video':
                    send = (media, generative) => search.withNearVideo({
                        ...Serialize.search.nearVideo({ video: media }),
                        generative,
                    });
                    break;
                default:
                    throw new WeaviateInvalidInputError(`Invalid media type: ${type}`);
            }
            return Promise.all([
                toBase64FromMedia(media),
                Serialize.generative({ supportsSingleGrouped }, generate),
            ]).then(([media, generative]) => send(media, generative));
        })
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
}
export default GenerateManager.use;
export { generativeParameters } from './config.js';
