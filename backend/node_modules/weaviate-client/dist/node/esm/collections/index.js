import ClassExists from '../schema/classExists.js';
import { ClassCreator, ClassDeleter, ClassGetter, SchemaGetter } from '../schema/index.js';
import collection from './collection/index.js';
import { classToCollection, makeVectorsConfig, resolveProperty, resolveReference } from './config/utils.js';
const collections = (connection, dbVersionSupport) => {
    const listAll = () => new SchemaGetter(connection)
        .do()
        .then((schema) => (schema.classes ? schema.classes.map((classToCollection)) : []));
    const deleteCollection = (name) => new ClassDeleter(connection).withClassName(name).do();
    return {
        create: async function (config) {
            const { name, invertedIndex, multiTenancy, objectTTL, replication, sharding, ...rest } = config;
            const moduleConfig = {};
            if (config.generative) {
                const generative = config.generative.name === 'generative-azure-openai' ? 'generative-openai' : config.generative.name;
                moduleConfig[generative] = config.generative.config ? config.generative.config : {};
            }
            if (config.reranker) {
                moduleConfig[config.reranker.name] = config.reranker.config ? config.reranker.config : {};
            }
            let objectTtlConfig;
            if (objectTTL) {
                objectTtlConfig = {
                    enabled: objectTTL.enabled,
                    deleteOn: objectTTL.deleteOn,
                    defaultTtl: objectTTL.defaultTTLSeconds,
                    filterExpiredObjects: objectTTL.filterExpiredObjects,
                };
            }
            const schema = {
                ...rest,
                class: name,
                invertedIndexConfig: invertedIndex,
                moduleConfig: moduleConfig,
                multiTenancyConfig: multiTenancy,
                objectTtlConfig: objectTtlConfig,
                replicationConfig: replication,
                shardingConfig: sharding,
            };
            const { vectorsConfig, vectorizers } = config.vectorizers
                ? makeVectorsConfig(config.vectorizers)
                : { vectorsConfig: undefined, vectorizers: [] };
            schema.vectorConfig = vectorsConfig;
            const properties = config.properties
                ? config.properties.map((prop) => resolveProperty(prop, vectorizers))
                : [];
            const references = config.references ? config.references.map((resolveReference)) : [];
            schema.properties = [...properties, ...references];
            await new ClassCreator(connection).withClass(schema).do();
            return collection(connection, name, dbVersionSupport);
        },
        createFromSchema: async function (config) {
            const { class: name } = await new ClassCreator(connection).withClass(config).do();
            return collection(connection, name, dbVersionSupport);
        },
        delete: deleteCollection,
        deleteAll: () => listAll().then((configs) => Promise.all(configs?.map((c) => deleteCollection(c.name)))),
        exists: (name) => new ClassExists(connection).withClassName(name).do(),
        export: (name) => new ClassGetter(connection)
            .withClassName(name)
            .do()
            .then((classToCollection)),
        listAll: listAll,
        get: (name) => collection(connection, name, dbVersionSupport),
        use: (name) => collection(connection, name, dbVersionSupport),
    };
};
export default collections;
export * from './aggregate/index.js';
export * from './backup/index.js';
export * from './cluster/index.js';
export * from './collection/index.js';
export * from './config/index.js';
export * from './configure/index.js';
export * from './data/index.js';
export * from './filters/index.js';
export * from './generate/index.js';
export * from './iterator/index.js';
export * from './query/index.js';
export * from './references/index.js';
export * from './sort/index.js';
export * from './tenants/index.js';
export * from './types/index.js';
export * from './vectors/multiTargetVector.js';
