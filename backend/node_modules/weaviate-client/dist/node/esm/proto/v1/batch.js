// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: v1/batch.proto
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Struct } from "../google/protobuf/struct.js";
import { BooleanArrayProperties, consistencyLevelFromJSON, consistencyLevelToJSON, IntArrayProperties, NumberArrayProperties, ObjectArrayProperties, ObjectProperties, TextArrayProperties, Vectors, } from "./base.js";
export const protobufPackage = "weaviate.v1";
function createBaseBatchObjectsRequest() {
    return { objects: [], consistencyLevel: undefined };
}
export const BatchObjectsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.objects) {
            BatchObject.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.consistencyLevel !== undefined) {
            writer.uint32(16).int32(message.consistencyLevel);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchObjectsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.objects.push(BatchObject.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.consistencyLevel = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            objects: globalThis.Array.isArray(object?.objects) ? object.objects.map((e) => BatchObject.fromJSON(e)) : [],
            consistencyLevel: isSet(object.consistencyLevel) ? consistencyLevelFromJSON(object.consistencyLevel) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.objects?.length) {
            obj.objects = message.objects.map((e) => BatchObject.toJSON(e));
        }
        if (message.consistencyLevel !== undefined) {
            obj.consistencyLevel = consistencyLevelToJSON(message.consistencyLevel);
        }
        return obj;
    },
    create(base) {
        return BatchObjectsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchObjectsRequest();
        message.objects = object.objects?.map((e) => BatchObject.fromPartial(e)) || [];
        message.consistencyLevel = object.consistencyLevel ?? undefined;
        return message;
    },
};
function createBaseBatchReferencesRequest() {
    return { references: [], consistencyLevel: undefined };
}
export const BatchReferencesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.references) {
            BatchReference.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.consistencyLevel !== undefined) {
            writer.uint32(16).int32(message.consistencyLevel);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchReferencesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.references.push(BatchReference.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.consistencyLevel = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            references: globalThis.Array.isArray(object?.references)
                ? object.references.map((e) => BatchReference.fromJSON(e))
                : [],
            consistencyLevel: isSet(object.consistencyLevel) ? consistencyLevelFromJSON(object.consistencyLevel) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.references?.length) {
            obj.references = message.references.map((e) => BatchReference.toJSON(e));
        }
        if (message.consistencyLevel !== undefined) {
            obj.consistencyLevel = consistencyLevelToJSON(message.consistencyLevel);
        }
        return obj;
    },
    create(base) {
        return BatchReferencesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchReferencesRequest();
        message.references = object.references?.map((e) => BatchReference.fromPartial(e)) || [];
        message.consistencyLevel = object.consistencyLevel ?? undefined;
        return message;
    },
};
function createBaseBatchStreamRequest() {
    return { start: undefined, data: undefined, stop: undefined };
}
export const BatchStreamRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.start !== undefined) {
            BatchStreamRequest_Start.encode(message.start, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            BatchStreamRequest_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.stop !== undefined) {
            BatchStreamRequest_Stop.encode(message.stop, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.start = BatchStreamRequest_Start.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = BatchStreamRequest_Data.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.stop = BatchStreamRequest_Stop.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            start: isSet(object.start) ? BatchStreamRequest_Start.fromJSON(object.start) : undefined,
            data: isSet(object.data) ? BatchStreamRequest_Data.fromJSON(object.data) : undefined,
            stop: isSet(object.stop) ? BatchStreamRequest_Stop.fromJSON(object.stop) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.start !== undefined) {
            obj.start = BatchStreamRequest_Start.toJSON(message.start);
        }
        if (message.data !== undefined) {
            obj.data = BatchStreamRequest_Data.toJSON(message.data);
        }
        if (message.stop !== undefined) {
            obj.stop = BatchStreamRequest_Stop.toJSON(message.stop);
        }
        return obj;
    },
    create(base) {
        return BatchStreamRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamRequest();
        message.start = (object.start !== undefined && object.start !== null)
            ? BatchStreamRequest_Start.fromPartial(object.start)
            : undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? BatchStreamRequest_Data.fromPartial(object.data)
            : undefined;
        message.stop = (object.stop !== undefined && object.stop !== null)
            ? BatchStreamRequest_Stop.fromPartial(object.stop)
            : undefined;
        return message;
    },
};
function createBaseBatchStreamRequest_Start() {
    return { consistencyLevel: undefined };
}
export const BatchStreamRequest_Start = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.consistencyLevel !== undefined) {
            writer.uint32(8).int32(message.consistencyLevel);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamRequest_Start();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.consistencyLevel = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            consistencyLevel: isSet(object.consistencyLevel) ? consistencyLevelFromJSON(object.consistencyLevel) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.consistencyLevel !== undefined) {
            obj.consistencyLevel = consistencyLevelToJSON(message.consistencyLevel);
        }
        return obj;
    },
    create(base) {
        return BatchStreamRequest_Start.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamRequest_Start();
        message.consistencyLevel = object.consistencyLevel ?? undefined;
        return message;
    },
};
function createBaseBatchStreamRequest_Stop() {
    return {};
}
export const BatchStreamRequest_Stop = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamRequest_Stop();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return BatchStreamRequest_Stop.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseBatchStreamRequest_Stop();
        return message;
    },
};
function createBaseBatchStreamRequest_Data() {
    return { objects: undefined, references: undefined };
}
export const BatchStreamRequest_Data = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.objects !== undefined) {
            BatchStreamRequest_Data_Objects.encode(message.objects, writer.uint32(10).fork()).ldelim();
        }
        if (message.references !== undefined) {
            BatchStreamRequest_Data_References.encode(message.references, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamRequest_Data();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.objects = BatchStreamRequest_Data_Objects.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.references = BatchStreamRequest_Data_References.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            objects: isSet(object.objects) ? BatchStreamRequest_Data_Objects.fromJSON(object.objects) : undefined,
            references: isSet(object.references) ? BatchStreamRequest_Data_References.fromJSON(object.references) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.objects !== undefined) {
            obj.objects = BatchStreamRequest_Data_Objects.toJSON(message.objects);
        }
        if (message.references !== undefined) {
            obj.references = BatchStreamRequest_Data_References.toJSON(message.references);
        }
        return obj;
    },
    create(base) {
        return BatchStreamRequest_Data.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamRequest_Data();
        message.objects = (object.objects !== undefined && object.objects !== null)
            ? BatchStreamRequest_Data_Objects.fromPartial(object.objects)
            : undefined;
        message.references = (object.references !== undefined && object.references !== null)
            ? BatchStreamRequest_Data_References.fromPartial(object.references)
            : undefined;
        return message;
    },
};
function createBaseBatchStreamRequest_Data_Objects() {
    return { values: [] };
}
export const BatchStreamRequest_Data_Objects = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.values) {
            BatchObject.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamRequest_Data_Objects();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.values.push(BatchObject.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => BatchObject.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.values?.length) {
            obj.values = message.values.map((e) => BatchObject.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return BatchStreamRequest_Data_Objects.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamRequest_Data_Objects();
        message.values = object.values?.map((e) => BatchObject.fromPartial(e)) || [];
        return message;
    },
};
function createBaseBatchStreamRequest_Data_References() {
    return { values: [] };
}
export const BatchStreamRequest_Data_References = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.values) {
            BatchReference.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamRequest_Data_References();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.values.push(BatchReference.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => BatchReference.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.values?.length) {
            obj.values = message.values.map((e) => BatchReference.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return BatchStreamRequest_Data_References.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamRequest_Data_References();
        message.values = object.values?.map((e) => BatchReference.fromPartial(e)) || [];
        return message;
    },
};
function createBaseBatchStreamReply() {
    return {
        results: undefined,
        shuttingDown: undefined,
        shutdown: undefined,
        started: undefined,
        backoff: undefined,
        acks: undefined,
        outOfMemory: undefined,
    };
}
export const BatchStreamReply = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.results !== undefined) {
            BatchStreamReply_Results.encode(message.results, writer.uint32(10).fork()).ldelim();
        }
        if (message.shuttingDown !== undefined) {
            BatchStreamReply_ShuttingDown.encode(message.shuttingDown, writer.uint32(18).fork()).ldelim();
        }
        if (message.shutdown !== undefined) {
            BatchStreamReply_Shutdown.encode(message.shutdown, writer.uint32(26).fork()).ldelim();
        }
        if (message.started !== undefined) {
            BatchStreamReply_Started.encode(message.started, writer.uint32(34).fork()).ldelim();
        }
        if (message.backoff !== undefined) {
            BatchStreamReply_Backoff.encode(message.backoff, writer.uint32(42).fork()).ldelim();
        }
        if (message.acks !== undefined) {
            BatchStreamReply_Acks.encode(message.acks, writer.uint32(50).fork()).ldelim();
        }
        if (message.outOfMemory !== undefined) {
            BatchStreamReply_OutOfMemory.encode(message.outOfMemory, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamReply();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results = BatchStreamReply_Results.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.shuttingDown = BatchStreamReply_ShuttingDown.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.shutdown = BatchStreamReply_Shutdown.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.started = BatchStreamReply_Started.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.backoff = BatchStreamReply_Backoff.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.acks = BatchStreamReply_Acks.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.outOfMemory = BatchStreamReply_OutOfMemory.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            results: isSet(object.results) ? BatchStreamReply_Results.fromJSON(object.results) : undefined,
            shuttingDown: isSet(object.shuttingDown)
                ? BatchStreamReply_ShuttingDown.fromJSON(object.shuttingDown)
                : undefined,
            shutdown: isSet(object.shutdown) ? BatchStreamReply_Shutdown.fromJSON(object.shutdown) : undefined,
            started: isSet(object.started) ? BatchStreamReply_Started.fromJSON(object.started) : undefined,
            backoff: isSet(object.backoff) ? BatchStreamReply_Backoff.fromJSON(object.backoff) : undefined,
            acks: isSet(object.acks) ? BatchStreamReply_Acks.fromJSON(object.acks) : undefined,
            outOfMemory: isSet(object.outOfMemory) ? BatchStreamReply_OutOfMemory.fromJSON(object.outOfMemory) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.results !== undefined) {
            obj.results = BatchStreamReply_Results.toJSON(message.results);
        }
        if (message.shuttingDown !== undefined) {
            obj.shuttingDown = BatchStreamReply_ShuttingDown.toJSON(message.shuttingDown);
        }
        if (message.shutdown !== undefined) {
            obj.shutdown = BatchStreamReply_Shutdown.toJSON(message.shutdown);
        }
        if (message.started !== undefined) {
            obj.started = BatchStreamReply_Started.toJSON(message.started);
        }
        if (message.backoff !== undefined) {
            obj.backoff = BatchStreamReply_Backoff.toJSON(message.backoff);
        }
        if (message.acks !== undefined) {
            obj.acks = BatchStreamReply_Acks.toJSON(message.acks);
        }
        if (message.outOfMemory !== undefined) {
            obj.outOfMemory = BatchStreamReply_OutOfMemory.toJSON(message.outOfMemory);
        }
        return obj;
    },
    create(base) {
        return BatchStreamReply.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamReply();
        message.results = (object.results !== undefined && object.results !== null)
            ? BatchStreamReply_Results.fromPartial(object.results)
            : undefined;
        message.shuttingDown = (object.shuttingDown !== undefined && object.shuttingDown !== null)
            ? BatchStreamReply_ShuttingDown.fromPartial(object.shuttingDown)
            : undefined;
        message.shutdown = (object.shutdown !== undefined && object.shutdown !== null)
            ? BatchStreamReply_Shutdown.fromPartial(object.shutdown)
            : undefined;
        message.started = (object.started !== undefined && object.started !== null)
            ? BatchStreamReply_Started.fromPartial(object.started)
            : undefined;
        message.backoff = (object.backoff !== undefined && object.backoff !== null)
            ? BatchStreamReply_Backoff.fromPartial(object.backoff)
            : undefined;
        message.acks = (object.acks !== undefined && object.acks !== null)
            ? BatchStreamReply_Acks.fromPartial(object.acks)
            : undefined;
        message.outOfMemory = (object.outOfMemory !== undefined && object.outOfMemory !== null)
            ? BatchStreamReply_OutOfMemory.fromPartial(object.outOfMemory)
            : undefined;
        return message;
    },
};
function createBaseBatchStreamReply_Started() {
    return {};
}
export const BatchStreamReply_Started = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamReply_Started();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return BatchStreamReply_Started.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseBatchStreamReply_Started();
        return message;
    },
};
function createBaseBatchStreamReply_ShuttingDown() {
    return {};
}
export const BatchStreamReply_ShuttingDown = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamReply_ShuttingDown();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return BatchStreamReply_ShuttingDown.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseBatchStreamReply_ShuttingDown();
        return message;
    },
};
function createBaseBatchStreamReply_Shutdown() {
    return {};
}
export const BatchStreamReply_Shutdown = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamReply_Shutdown();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return BatchStreamReply_Shutdown.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseBatchStreamReply_Shutdown();
        return message;
    },
};
function createBaseBatchStreamReply_OutOfMemory() {
    return { uuids: [], beacons: [] };
}
export const BatchStreamReply_OutOfMemory = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.uuids) {
            writer.uint32(10).string(v);
        }
        for (const v of message.beacons) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamReply_OutOfMemory();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.uuids.push(reader.string());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.beacons.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuids: globalThis.Array.isArray(object?.uuids) ? object.uuids.map((e) => globalThis.String(e)) : [],
            beacons: globalThis.Array.isArray(object?.beacons) ? object.beacons.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uuids?.length) {
            obj.uuids = message.uuids;
        }
        if (message.beacons?.length) {
            obj.beacons = message.beacons;
        }
        return obj;
    },
    create(base) {
        return BatchStreamReply_OutOfMemory.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamReply_OutOfMemory();
        message.uuids = object.uuids?.map((e) => e) || [];
        message.beacons = object.beacons?.map((e) => e) || [];
        return message;
    },
};
function createBaseBatchStreamReply_Backoff() {
    return { batchSize: 0 };
}
export const BatchStreamReply_Backoff = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.batchSize !== 0) {
            writer.uint32(8).int32(message.batchSize);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamReply_Backoff();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.batchSize = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { batchSize: isSet(object.batchSize) ? globalThis.Number(object.batchSize) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.batchSize !== 0) {
            obj.batchSize = Math.round(message.batchSize);
        }
        return obj;
    },
    create(base) {
        return BatchStreamReply_Backoff.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamReply_Backoff();
        message.batchSize = object.batchSize ?? 0;
        return message;
    },
};
function createBaseBatchStreamReply_Acks() {
    return { uuids: [], beacons: [] };
}
export const BatchStreamReply_Acks = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.uuids) {
            writer.uint32(10).string(v);
        }
        for (const v of message.beacons) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamReply_Acks();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.uuids.push(reader.string());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.beacons.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuids: globalThis.Array.isArray(object?.uuids) ? object.uuids.map((e) => globalThis.String(e)) : [],
            beacons: globalThis.Array.isArray(object?.beacons) ? object.beacons.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uuids?.length) {
            obj.uuids = message.uuids;
        }
        if (message.beacons?.length) {
            obj.beacons = message.beacons;
        }
        return obj;
    },
    create(base) {
        return BatchStreamReply_Acks.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamReply_Acks();
        message.uuids = object.uuids?.map((e) => e) || [];
        message.beacons = object.beacons?.map((e) => e) || [];
        return message;
    },
};
function createBaseBatchStreamReply_Results() {
    return { errors: [], successes: [] };
}
export const BatchStreamReply_Results = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.errors) {
            BatchStreamReply_Results_Error.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.successes) {
            BatchStreamReply_Results_Success.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamReply_Results();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.errors.push(BatchStreamReply_Results_Error.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.successes.push(BatchStreamReply_Results_Success.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            errors: globalThis.Array.isArray(object?.errors)
                ? object.errors.map((e) => BatchStreamReply_Results_Error.fromJSON(e))
                : [],
            successes: globalThis.Array.isArray(object?.successes)
                ? object.successes.map((e) => BatchStreamReply_Results_Success.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.errors?.length) {
            obj.errors = message.errors.map((e) => BatchStreamReply_Results_Error.toJSON(e));
        }
        if (message.successes?.length) {
            obj.successes = message.successes.map((e) => BatchStreamReply_Results_Success.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return BatchStreamReply_Results.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamReply_Results();
        message.errors = object.errors?.map((e) => BatchStreamReply_Results_Error.fromPartial(e)) || [];
        message.successes = object.successes?.map((e) => BatchStreamReply_Results_Success.fromPartial(e)) || [];
        return message;
    },
};
function createBaseBatchStreamReply_Results_Error() {
    return { error: "", uuid: undefined, beacon: undefined };
}
export const BatchStreamReply_Results_Error = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.error !== "") {
            writer.uint32(10).string(message.error);
        }
        if (message.uuid !== undefined) {
            writer.uint32(18).string(message.uuid);
        }
        if (message.beacon !== undefined) {
            writer.uint32(26).string(message.beacon);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamReply_Results_Error();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.uuid = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.beacon = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            error: isSet(object.error) ? globalThis.String(object.error) : "",
            uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : undefined,
            beacon: isSet(object.beacon) ? globalThis.String(object.beacon) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.error !== "") {
            obj.error = message.error;
        }
        if (message.uuid !== undefined) {
            obj.uuid = message.uuid;
        }
        if (message.beacon !== undefined) {
            obj.beacon = message.beacon;
        }
        return obj;
    },
    create(base) {
        return BatchStreamReply_Results_Error.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamReply_Results_Error();
        message.error = object.error ?? "";
        message.uuid = object.uuid ?? undefined;
        message.beacon = object.beacon ?? undefined;
        return message;
    },
};
function createBaseBatchStreamReply_Results_Success() {
    return { uuid: undefined, beacon: undefined };
}
export const BatchStreamReply_Results_Success = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.uuid !== undefined) {
            writer.uint32(18).string(message.uuid);
        }
        if (message.beacon !== undefined) {
            writer.uint32(26).string(message.beacon);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchStreamReply_Results_Success();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.uuid = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.beacon = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : undefined,
            beacon: isSet(object.beacon) ? globalThis.String(object.beacon) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uuid !== undefined) {
            obj.uuid = message.uuid;
        }
        if (message.beacon !== undefined) {
            obj.beacon = message.beacon;
        }
        return obj;
    },
    create(base) {
        return BatchStreamReply_Results_Success.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchStreamReply_Results_Success();
        message.uuid = object.uuid ?? undefined;
        message.beacon = object.beacon ?? undefined;
        return message;
    },
};
function createBaseBatchObject() {
    return {
        uuid: "",
        vector: [],
        properties: undefined,
        collection: "",
        tenant: "",
        vectorBytes: new Uint8Array(0),
        vectors: [],
    };
}
export const BatchObject = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.uuid !== "") {
            writer.uint32(10).string(message.uuid);
        }
        writer.uint32(18).fork();
        for (const v of message.vector) {
            writer.float(v);
        }
        writer.ldelim();
        if (message.properties !== undefined) {
            BatchObject_Properties.encode(message.properties, writer.uint32(26).fork()).ldelim();
        }
        if (message.collection !== "") {
            writer.uint32(34).string(message.collection);
        }
        if (message.tenant !== "") {
            writer.uint32(42).string(message.tenant);
        }
        if (message.vectorBytes.length !== 0) {
            writer.uint32(50).bytes(message.vectorBytes);
        }
        for (const v of message.vectors) {
            Vectors.encode(v, writer.uint32(186).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.uuid = reader.string();
                    continue;
                case 2:
                    if (tag === 21) {
                        message.vector.push(reader.float());
                        continue;
                    }
                    if (tag === 18) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.vector.push(reader.float());
                        }
                        continue;
                    }
                    break;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.properties = BatchObject_Properties.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.collection = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.tenant = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.vectorBytes = reader.bytes();
                    continue;
                case 23:
                    if (tag !== 186) {
                        break;
                    }
                    message.vectors.push(Vectors.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
            vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e) => globalThis.Number(e)) : [],
            properties: isSet(object.properties) ? BatchObject_Properties.fromJSON(object.properties) : undefined,
            collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
            tenant: isSet(object.tenant) ? globalThis.String(object.tenant) : "",
            vectorBytes: isSet(object.vectorBytes) ? bytesFromBase64(object.vectorBytes) : new Uint8Array(0),
            vectors: globalThis.Array.isArray(object?.vectors) ? object.vectors.map((e) => Vectors.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uuid !== "") {
            obj.uuid = message.uuid;
        }
        if (message.vector?.length) {
            obj.vector = message.vector;
        }
        if (message.properties !== undefined) {
            obj.properties = BatchObject_Properties.toJSON(message.properties);
        }
        if (message.collection !== "") {
            obj.collection = message.collection;
        }
        if (message.tenant !== "") {
            obj.tenant = message.tenant;
        }
        if (message.vectorBytes.length !== 0) {
            obj.vectorBytes = base64FromBytes(message.vectorBytes);
        }
        if (message.vectors?.length) {
            obj.vectors = message.vectors.map((e) => Vectors.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return BatchObject.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchObject();
        message.uuid = object.uuid ?? "";
        message.vector = object.vector?.map((e) => e) || [];
        message.properties = (object.properties !== undefined && object.properties !== null)
            ? BatchObject_Properties.fromPartial(object.properties)
            : undefined;
        message.collection = object.collection ?? "";
        message.tenant = object.tenant ?? "";
        message.vectorBytes = object.vectorBytes ?? new Uint8Array(0);
        message.vectors = object.vectors?.map((e) => Vectors.fromPartial(e)) || [];
        return message;
    },
};
function createBaseBatchObject_Properties() {
    return {
        nonRefProperties: undefined,
        singleTargetRefProps: [],
        multiTargetRefProps: [],
        numberArrayProperties: [],
        intArrayProperties: [],
        textArrayProperties: [],
        booleanArrayProperties: [],
        objectProperties: [],
        objectArrayProperties: [],
        emptyListProps: [],
    };
}
export const BatchObject_Properties = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.nonRefProperties !== undefined) {
            Struct.encode(Struct.wrap(message.nonRefProperties), writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.singleTargetRefProps) {
            BatchObject_SingleTargetRefProps.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.multiTargetRefProps) {
            BatchObject_MultiTargetRefProps.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.numberArrayProperties) {
            NumberArrayProperties.encode(v, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.intArrayProperties) {
            IntArrayProperties.encode(v, writer.uint32(42).fork()).ldelim();
        }
        for (const v of message.textArrayProperties) {
            TextArrayProperties.encode(v, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.booleanArrayProperties) {
            BooleanArrayProperties.encode(v, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.objectProperties) {
            ObjectProperties.encode(v, writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.objectArrayProperties) {
            ObjectArrayProperties.encode(v, writer.uint32(74).fork()).ldelim();
        }
        for (const v of message.emptyListProps) {
            writer.uint32(82).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchObject_Properties();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nonRefProperties = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.singleTargetRefProps.push(BatchObject_SingleTargetRefProps.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.multiTargetRefProps.push(BatchObject_MultiTargetRefProps.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.numberArrayProperties.push(NumberArrayProperties.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.intArrayProperties.push(IntArrayProperties.decode(reader, reader.uint32()));
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.textArrayProperties.push(TextArrayProperties.decode(reader, reader.uint32()));
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.booleanArrayProperties.push(BooleanArrayProperties.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.objectProperties.push(ObjectProperties.decode(reader, reader.uint32()));
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.objectArrayProperties.push(ObjectArrayProperties.decode(reader, reader.uint32()));
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.emptyListProps.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nonRefProperties: isObject(object.nonRefProperties) ? object.nonRefProperties : undefined,
            singleTargetRefProps: globalThis.Array.isArray(object?.singleTargetRefProps)
                ? object.singleTargetRefProps.map((e) => BatchObject_SingleTargetRefProps.fromJSON(e))
                : [],
            multiTargetRefProps: globalThis.Array.isArray(object?.multiTargetRefProps)
                ? object.multiTargetRefProps.map((e) => BatchObject_MultiTargetRefProps.fromJSON(e))
                : [],
            numberArrayProperties: globalThis.Array.isArray(object?.numberArrayProperties)
                ? object.numberArrayProperties.map((e) => NumberArrayProperties.fromJSON(e))
                : [],
            intArrayProperties: globalThis.Array.isArray(object?.intArrayProperties)
                ? object.intArrayProperties.map((e) => IntArrayProperties.fromJSON(e))
                : [],
            textArrayProperties: globalThis.Array.isArray(object?.textArrayProperties)
                ? object.textArrayProperties.map((e) => TextArrayProperties.fromJSON(e))
                : [],
            booleanArrayProperties: globalThis.Array.isArray(object?.booleanArrayProperties)
                ? object.booleanArrayProperties.map((e) => BooleanArrayProperties.fromJSON(e))
                : [],
            objectProperties: globalThis.Array.isArray(object?.objectProperties)
                ? object.objectProperties.map((e) => ObjectProperties.fromJSON(e))
                : [],
            objectArrayProperties: globalThis.Array.isArray(object?.objectArrayProperties)
                ? object.objectArrayProperties.map((e) => ObjectArrayProperties.fromJSON(e))
                : [],
            emptyListProps: globalThis.Array.isArray(object?.emptyListProps)
                ? object.emptyListProps.map((e) => globalThis.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nonRefProperties !== undefined) {
            obj.nonRefProperties = message.nonRefProperties;
        }
        if (message.singleTargetRefProps?.length) {
            obj.singleTargetRefProps = message.singleTargetRefProps.map((e) => BatchObject_SingleTargetRefProps.toJSON(e));
        }
        if (message.multiTargetRefProps?.length) {
            obj.multiTargetRefProps = message.multiTargetRefProps.map((e) => BatchObject_MultiTargetRefProps.toJSON(e));
        }
        if (message.numberArrayProperties?.length) {
            obj.numberArrayProperties = message.numberArrayProperties.map((e) => NumberArrayProperties.toJSON(e));
        }
        if (message.intArrayProperties?.length) {
            obj.intArrayProperties = message.intArrayProperties.map((e) => IntArrayProperties.toJSON(e));
        }
        if (message.textArrayProperties?.length) {
            obj.textArrayProperties = message.textArrayProperties.map((e) => TextArrayProperties.toJSON(e));
        }
        if (message.booleanArrayProperties?.length) {
            obj.booleanArrayProperties = message.booleanArrayProperties.map((e) => BooleanArrayProperties.toJSON(e));
        }
        if (message.objectProperties?.length) {
            obj.objectProperties = message.objectProperties.map((e) => ObjectProperties.toJSON(e));
        }
        if (message.objectArrayProperties?.length) {
            obj.objectArrayProperties = message.objectArrayProperties.map((e) => ObjectArrayProperties.toJSON(e));
        }
        if (message.emptyListProps?.length) {
            obj.emptyListProps = message.emptyListProps;
        }
        return obj;
    },
    create(base) {
        return BatchObject_Properties.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchObject_Properties();
        message.nonRefProperties = object.nonRefProperties ?? undefined;
        message.singleTargetRefProps =
            object.singleTargetRefProps?.map((e) => BatchObject_SingleTargetRefProps.fromPartial(e)) || [];
        message.multiTargetRefProps =
            object.multiTargetRefProps?.map((e) => BatchObject_MultiTargetRefProps.fromPartial(e)) || [];
        message.numberArrayProperties = object.numberArrayProperties?.map((e) => NumberArrayProperties.fromPartial(e)) ||
            [];
        message.intArrayProperties = object.intArrayProperties?.map((e) => IntArrayProperties.fromPartial(e)) || [];
        message.textArrayProperties = object.textArrayProperties?.map((e) => TextArrayProperties.fromPartial(e)) || [];
        message.booleanArrayProperties = object.booleanArrayProperties?.map((e) => BooleanArrayProperties.fromPartial(e)) ||
            [];
        message.objectProperties = object.objectProperties?.map((e) => ObjectProperties.fromPartial(e)) || [];
        message.objectArrayProperties = object.objectArrayProperties?.map((e) => ObjectArrayProperties.fromPartial(e)) ||
            [];
        message.emptyListProps = object.emptyListProps?.map((e) => e) || [];
        return message;
    },
};
function createBaseBatchObject_SingleTargetRefProps() {
    return { uuids: [], propName: "" };
}
export const BatchObject_SingleTargetRefProps = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.uuids) {
            writer.uint32(10).string(v);
        }
        if (message.propName !== "") {
            writer.uint32(18).string(message.propName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchObject_SingleTargetRefProps();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.uuids.push(reader.string());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.propName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuids: globalThis.Array.isArray(object?.uuids) ? object.uuids.map((e) => globalThis.String(e)) : [],
            propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uuids?.length) {
            obj.uuids = message.uuids;
        }
        if (message.propName !== "") {
            obj.propName = message.propName;
        }
        return obj;
    },
    create(base) {
        return BatchObject_SingleTargetRefProps.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchObject_SingleTargetRefProps();
        message.uuids = object.uuids?.map((e) => e) || [];
        message.propName = object.propName ?? "";
        return message;
    },
};
function createBaseBatchObject_MultiTargetRefProps() {
    return { uuids: [], propName: "", targetCollection: "" };
}
export const BatchObject_MultiTargetRefProps = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.uuids) {
            writer.uint32(10).string(v);
        }
        if (message.propName !== "") {
            writer.uint32(18).string(message.propName);
        }
        if (message.targetCollection !== "") {
            writer.uint32(26).string(message.targetCollection);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchObject_MultiTargetRefProps();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.uuids.push(reader.string());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.propName = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.targetCollection = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuids: globalThis.Array.isArray(object?.uuids) ? object.uuids.map((e) => globalThis.String(e)) : [],
            propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
            targetCollection: isSet(object.targetCollection) ? globalThis.String(object.targetCollection) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uuids?.length) {
            obj.uuids = message.uuids;
        }
        if (message.propName !== "") {
            obj.propName = message.propName;
        }
        if (message.targetCollection !== "") {
            obj.targetCollection = message.targetCollection;
        }
        return obj;
    },
    create(base) {
        return BatchObject_MultiTargetRefProps.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchObject_MultiTargetRefProps();
        message.uuids = object.uuids?.map((e) => e) || [];
        message.propName = object.propName ?? "";
        message.targetCollection = object.targetCollection ?? "";
        return message;
    },
};
function createBaseBatchReference() {
    return { name: "", fromCollection: "", fromUuid: "", toCollection: undefined, toUuid: "", tenant: "" };
}
export const BatchReference = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.fromCollection !== "") {
            writer.uint32(18).string(message.fromCollection);
        }
        if (message.fromUuid !== "") {
            writer.uint32(26).string(message.fromUuid);
        }
        if (message.toCollection !== undefined) {
            writer.uint32(34).string(message.toCollection);
        }
        if (message.toUuid !== "") {
            writer.uint32(42).string(message.toUuid);
        }
        if (message.tenant !== "") {
            writer.uint32(50).string(message.tenant);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchReference();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fromCollection = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.fromUuid = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.toCollection = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.toUuid = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.tenant = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            fromCollection: isSet(object.fromCollection) ? globalThis.String(object.fromCollection) : "",
            fromUuid: isSet(object.fromUuid) ? globalThis.String(object.fromUuid) : "",
            toCollection: isSet(object.toCollection) ? globalThis.String(object.toCollection) : undefined,
            toUuid: isSet(object.toUuid) ? globalThis.String(object.toUuid) : "",
            tenant: isSet(object.tenant) ? globalThis.String(object.tenant) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.fromCollection !== "") {
            obj.fromCollection = message.fromCollection;
        }
        if (message.fromUuid !== "") {
            obj.fromUuid = message.fromUuid;
        }
        if (message.toCollection !== undefined) {
            obj.toCollection = message.toCollection;
        }
        if (message.toUuid !== "") {
            obj.toUuid = message.toUuid;
        }
        if (message.tenant !== "") {
            obj.tenant = message.tenant;
        }
        return obj;
    },
    create(base) {
        return BatchReference.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchReference();
        message.name = object.name ?? "";
        message.fromCollection = object.fromCollection ?? "";
        message.fromUuid = object.fromUuid ?? "";
        message.toCollection = object.toCollection ?? undefined;
        message.toUuid = object.toUuid ?? "";
        message.tenant = object.tenant ?? "";
        return message;
    },
};
function createBaseBatchObjectsReply() {
    return { took: 0, errors: [] };
}
export const BatchObjectsReply = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.took !== 0) {
            writer.uint32(13).float(message.took);
        }
        for (const v of message.errors) {
            BatchObjectsReply_BatchError.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchObjectsReply();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 13) {
                        break;
                    }
                    message.took = reader.float();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.errors.push(BatchObjectsReply_BatchError.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            took: isSet(object.took) ? globalThis.Number(object.took) : 0,
            errors: globalThis.Array.isArray(object?.errors)
                ? object.errors.map((e) => BatchObjectsReply_BatchError.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.took !== 0) {
            obj.took = message.took;
        }
        if (message.errors?.length) {
            obj.errors = message.errors.map((e) => BatchObjectsReply_BatchError.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return BatchObjectsReply.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchObjectsReply();
        message.took = object.took ?? 0;
        message.errors = object.errors?.map((e) => BatchObjectsReply_BatchError.fromPartial(e)) || [];
        return message;
    },
};
function createBaseBatchObjectsReply_BatchError() {
    return { index: 0, error: "" };
}
export const BatchObjectsReply_BatchError = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.index !== 0) {
            writer.uint32(8).int32(message.index);
        }
        if (message.error !== "") {
            writer.uint32(18).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchObjectsReply_BatchError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.index = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            index: isSet(object.index) ? globalThis.Number(object.index) : 0,
            error: isSet(object.error) ? globalThis.String(object.error) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.index !== 0) {
            obj.index = Math.round(message.index);
        }
        if (message.error !== "") {
            obj.error = message.error;
        }
        return obj;
    },
    create(base) {
        return BatchObjectsReply_BatchError.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchObjectsReply_BatchError();
        message.index = object.index ?? 0;
        message.error = object.error ?? "";
        return message;
    },
};
function createBaseBatchReferencesReply() {
    return { took: 0, errors: [] };
}
export const BatchReferencesReply = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.took !== 0) {
            writer.uint32(13).float(message.took);
        }
        for (const v of message.errors) {
            BatchReferencesReply_BatchError.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchReferencesReply();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 13) {
                        break;
                    }
                    message.took = reader.float();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.errors.push(BatchReferencesReply_BatchError.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            took: isSet(object.took) ? globalThis.Number(object.took) : 0,
            errors: globalThis.Array.isArray(object?.errors)
                ? object.errors.map((e) => BatchReferencesReply_BatchError.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.took !== 0) {
            obj.took = message.took;
        }
        if (message.errors?.length) {
            obj.errors = message.errors.map((e) => BatchReferencesReply_BatchError.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return BatchReferencesReply.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchReferencesReply();
        message.took = object.took ?? 0;
        message.errors = object.errors?.map((e) => BatchReferencesReply_BatchError.fromPartial(e)) || [];
        return message;
    },
};
function createBaseBatchReferencesReply_BatchError() {
    return { index: 0, error: "" };
}
export const BatchReferencesReply_BatchError = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.index !== 0) {
            writer.uint32(8).int32(message.index);
        }
        if (message.error !== "") {
            writer.uint32(18).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchReferencesReply_BatchError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.index = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            index: isSet(object.index) ? globalThis.Number(object.index) : 0,
            error: isSet(object.error) ? globalThis.String(object.error) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.index !== 0) {
            obj.index = Math.round(message.index);
        }
        if (message.error !== "") {
            obj.error = message.error;
        }
        return obj;
    },
    create(base) {
        return BatchReferencesReply_BatchError.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchReferencesReply_BatchError();
        message.index = object.index ?? 0;
        message.error = object.error ?? "";
        return message;
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
