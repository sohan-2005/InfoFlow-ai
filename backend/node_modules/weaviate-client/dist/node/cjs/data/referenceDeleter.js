"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commandBase_js_1 = require("../validation/commandBase.js");
class ReferenceDeleter extends commandBase_js_1.CommandBase {
    beaconPath;
    className;
    consistencyLevel;
    id;
    reference;
    referencesPath;
    refProp;
    tenant;
    constructor(client, referencesPath, beaconPath) {
        super(client);
        this.referencesPath = referencesPath;
        this.beaconPath = beaconPath;
    }
    withId = (id) => {
        this.id = id;
        return this;
    };
    withClassName(className) {
        this.className = className;
        return this;
    }
    withReference = (ref) => {
        this.reference = ref;
        return this;
    };
    withReferenceProperty = (refProp) => {
        this.refProp = refProp;
        return this;
    };
    withConsistencyLevel = (cl) => {
        this.consistencyLevel = cl;
        return this;
    };
    withTenant = (tenant) => {
        this.tenant = tenant;
        return this;
    };
    validateIsSet = (prop, name, setter) => {
        if (prop == undefined || prop == null || prop.length == 0) {
            this.addError(`${name} must be set - set with ${setter}`);
        }
    };
    validate = () => {
        this.validateIsSet(this.id, 'id', '.withId(id)');
        this.validateIsSet(this.refProp, 'referenceProperty', '.withReferenceProperty(refProp)');
    };
    payload = () => this.reference;
    do = () => {
        this.validate();
        if (this.errors.length > 0) {
            return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
        }
        if (!this.reference.beacon) {
            throw new Error('reference beacon must be set');
        }
        return Promise.all([
            this.referencesPath.build(this.id, this.className, this.refProp, this.consistencyLevel, this.tenant),
            this.beaconPath.rebuild(this.reference.beacon),
        ]).then((results) => {
            const path = results[0];
            const beacon = results[1];
            return this.client.delete(path, { beacon }, false);
        });
    };
}
exports.default = ReferenceDeleter;
