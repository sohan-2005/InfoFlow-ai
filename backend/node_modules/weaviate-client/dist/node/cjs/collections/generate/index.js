"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generativeParameters = void 0;
const errors_js_1 = require("../../errors.js");
const index_js_1 = require("../../index.js");
const index_js_2 = require("../deserialize/index.js");
const check_js_1 = require("../query/check.js");
const index_js_3 = require("../serialize/index.js");
class GenerateManager {
    check;
    constructor(check) {
        this.check = check;
    }
    static use(connection, name, dbVersionSupport, consistencyLevel, tenant) {
        return new GenerateManager(new check_js_1.Check(connection, name, dbVersionSupport, consistencyLevel, tenant));
    }
    async parseReply(reply) {
        const deserialize = await index_js_2.Deserialize.use(this.check.dbVersionSupport);
        return deserialize.generate(reply);
    }
    async parseGroupByReply(opts, reply) {
        const deserialize = await index_js_2.Deserialize.use(this.check.dbVersionSupport);
        return index_js_3.Serialize.search.isGroupBy(opts)
            ? deserialize.generateGroupBy(reply)
            : deserialize.generate(reply);
    }
    fetchObjects(generate, opts) {
        return Promise.all([
            this.check.fetchObjects(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...index_js_3.Serialize.search.fetchObjects(opts),
                generative: await index_js_3.Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withFetch(args))
            .then((reply) => this.parseReply(reply));
    }
    bm25(query, generate, opts) {
        return Promise.all([
            this.check.bm25(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...index_js_3.Serialize.search.bm25(query, opts),
                generative: await index_js_3.Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withBm25(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    hybrid(query, generate, opts) {
        return Promise.all([
            this.check.hybridSearch(opts),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search, supportsVectors }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...(await index_js_3.Serialize.search.hybrid({
                    query,
                    supportsVectors,
                }, opts)),
                generative: await index_js_3.Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withHybrid(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    nearImage(image, generate, opts) {
        return Promise.all([
            this.check.nearSearch(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...index_js_3.Serialize.search.nearImage({
                    image: await (0, index_js_1.toBase64FromMedia)(image),
                }, opts),
                generative: await index_js_3.Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withNearImage(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    nearObject(id, generate, opts) {
        return Promise.all([
            this.check.nearSearch(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...index_js_3.Serialize.search.nearObject({
                    id,
                }, opts),
                generative: await index_js_3.Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withNearObject(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    nearText(query, generate, opts) {
        return Promise.all([
            this.check.nearSearch(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...index_js_3.Serialize.search.nearText({
                    query,
                }, opts),
                generative: await index_js_3.Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withNearText(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    nearVector(vector, generate, opts) {
        return Promise.all([
            this.check.nearVector(vector, opts),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(async ([{ search, supportsVectors }, supportsSingleGrouped]) => ({
            search,
            args: {
                ...(await index_js_3.Serialize.search.nearVector({
                    vector,
                    supportsVectors,
                }, opts)),
                generative: await index_js_3.Serialize.generative({ supportsSingleGrouped }, generate),
            },
        }))
            .then(({ search, args }) => search.withNearVector(args))
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
    nearMedia(media, type, generate, opts) {
        return Promise.all([
            this.check.nearSearch(),
            this.check.supportForSingleGroupedGenerative(),
            this.check.supportForGenerativeConfigRuntime(generate.config),
        ])
            .then(([{ search }, supportsSingleGrouped]) => {
            let send;
            switch (type) {
                case 'audio':
                    send = (media, generative) => search.withNearAudio({
                        ...index_js_3.Serialize.search.nearAudio({ audio: media }, opts),
                        generative,
                    });
                    break;
                case 'depth':
                    send = (media, generative) => search.withNearDepth({
                        ...index_js_3.Serialize.search.nearDepth({ depth: media }, opts),
                        generative,
                    });
                    break;
                case 'image':
                    send = (media, generative) => search.withNearImage({
                        ...index_js_3.Serialize.search.nearImage({ image: media }, opts),
                        generative,
                    });
                    break;
                case 'imu':
                    send = (media, generative) => search.withNearIMU({
                        ...index_js_3.Serialize.search.nearIMU({ imu: media }, opts),
                        generative,
                    });
                    break;
                case 'thermal':
                    send = (media, generative) => search.withNearThermal({
                        ...index_js_3.Serialize.search.nearThermal({ thermal: media }, opts),
                        generative,
                    });
                    break;
                case 'video':
                    send = (media, generative) => search.withNearVideo({
                        ...index_js_3.Serialize.search.nearVideo({ video: media }),
                        generative,
                    });
                    break;
                default:
                    throw new errors_js_1.WeaviateInvalidInputError(`Invalid media type: ${type}`);
            }
            return Promise.all([
                (0, index_js_1.toBase64FromMedia)(media),
                index_js_3.Serialize.generative({ supportsSingleGrouped }, generate),
            ]).then(([media, generative]) => send(media, generative));
        })
            .then((reply) => this.parseGroupByReply(opts, reply));
    }
}
exports.default = GenerateManager.use;
var config_js_1 = require("./config.js");
Object.defineProperty(exports, "generativeParameters", { enumerable: true, get: function () { return config_js_1.generativeParameters; } });
